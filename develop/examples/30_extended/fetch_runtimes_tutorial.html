<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Measuring runtimes for Scikit-learn models &#8212; OpenML 0.12.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/codehighlightstyle.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.12.4.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.4.1/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>
  
  <a href="https://github.com/openml/openml-python"
     class="visible-desktop hidden-xs"><img
    id="gh-banner"
    style="position: absolute; top: 50px; right: 0; border: 0;"
    src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"
    alt="Fork me on GitHub"></a>
  <script>
    // Adjust banner height.
    $(function () {
      var navHeight = $(".navbar .container").css("height");
      $("#gh-banner").css("top", navHeight);
    });
  </script>


  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          OpenML</a>
        <span class="navbar-text navbar-version pull-left"><b>0.12.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../index.html">Start</a></li>
                <li><a href="../../usage.html">User Guide</a></li>
                <li><a href="../../api.html">API</a></li>
                <li><a href="../index.html">Examples</a></li>
                <li><a href="../../extensions.html">Extensions</a></li>
                <li><a href="../../contributing.html">Contributing</a></li>
                <li><a href="../../progress.html">Changelog</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">Measuring runtimes for Scikit-learn models</a><ul>
<li><a class="reference internal" href="#preparing-tasks-and-scikit-learn-models">Preparing tasks and scikit-learn models</a></li>
<li><a class="reference internal" href="#case-1-running-a-random-forest-model-on-an-openml-task">Case 1: Running a Random Forest model on an OpenML task</a></li>
<li><a class="reference internal" href="#case-2-running-scikit-learn-model-on-an-openml-task-in-parallel">Case 2: Running Scikit-learn model on an OpenML task in parallel</a></li>
<li><a class="reference internal" href="#case-3-running-and-benchmarking-hpo-algorithms-with-their-runtimes">Case 3: Running and benchmarking HPO algorithms with their runtimes</a></li>
<li><a class="reference internal" href="#case-4-running-models-that-scikit-learn-doesn-t-parallelize">Case 4: Running models that scikit-learn doesn’t parallelize</a></li>
<li><a class="reference internal" href="#case-5-running-scikit-learn-models-that-don-t-release-gil">Case 5: Running Scikit-learn models that don’t release GIL</a></li>
<li><a class="reference internal" href="#summmary">Summmary</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-examples-30-extended-fetch-runtimes-tutorial-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<section class="sphx-glr-example-title" id="measuring-runtimes-for-scikit-learn-models">
<span id="sphx-glr-examples-30-extended-fetch-runtimes-tutorial-py"></span><h1>Measuring runtimes for Scikit-learn models<a class="headerlink" href="#measuring-runtimes-for-scikit-learn-models" title="Permalink to this headline">¶</a></h1>
<p>The runtime of machine learning models on specific datasets can be a deciding
factor on the choice of algorithms, especially for benchmarking and comparison
purposes. OpenML’s scikit-learn extension provides runtime data from runs of
model fit and prediction on tasks or datasets, for both the CPU-clock as well
as the actual wallclock-time incurred. The objective of this example is to
illustrate how to retrieve such timing measures, and also offer some potential
means of usage and interpretation of the same.</p>
<p>It should be noted that there are multiple levels at which parallelism can occur.</p>
<ul class="simple">
<li><p>At the outermost level, OpenML tasks contain fixed data splits, on which the
defined model/flow is executed. Thus, a model can be fit on each OpenML dataset fold
in parallel using the <cite>n_jobs</cite> parameter to <cite>run_model_on_task</cite> or <cite>run_flow_on_task</cite>
(illustrated under Case 2 &amp; 3 below).</p></li>
<li><p>The model/flow specified can also include scikit-learn models that perform their own
parallelization. For instance, by specifying <cite>n_jobs</cite> in a Random Forest model definition
(covered under Case 2 below).</p></li>
<li><p>The sklearn model can further be an HPO estimator and contain it’s own parallelization.
If the base estimator used also supports <cite>parallelization</cite>, then there’s at least a 2-level nested
definition for parallelization possible (covered under Case 3 below).</p></li>
</ul>
<p>We shall cover these 5 representative scenarios for:</p>
<ul class="simple">
<li><p>(Case 1) Retrieving runtimes for Random Forest training and prediction on each of the
cross-validation folds</p></li>
<li><p>(Case 2) Testing the above setting in a parallel setup and monitor the difference using
runtimes retrieved</p></li>
<li><p>(Case 3) Comparing RandomSearchCV and GridSearchCV on the above task based on runtimes</p></li>
<li><p>(Case 4) Running models that don’t run in parallel or models which scikit-learn doesn’t
parallelize</p></li>
<li><p>(Case 5) Running models that do not release the Python Global Interpreter Lock (GIL)</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># License: BSD 3-Clause</span>

<span class="kn">import</span> <span class="nn">openml</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">joblib.parallel</span> <span class="kn">import</span> <span class="n">parallel_backend</span>

<span class="kn">from</span> <span class="nn">sklearn.naive_bayes</span> <span class="kn">import</span> <span class="n">GaussianNB</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.neural_network</span> <span class="kn">import</span> <span class="n">MLPClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span><span class="p">,</span> <span class="n">RandomizedSearchCV</span>
</pre></div>
</div>
<section id="preparing-tasks-and-scikit-learn-models">
<h2>Preparing tasks and scikit-learn models<a class="headerlink" href="#preparing-tasks-and-scikit-learn-models" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">task_id</span> <span class="o">=</span> <span class="mi">167119</span>

<span class="n">task</span> <span class="o">=</span> <span class="n">openml</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">get_task</span><span class="p">(</span><span class="n">task_id</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

<span class="c1"># Viewing associated data</span>
<span class="n">n_repeats</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">get_split_dimensions</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span>
    <span class="s2">&quot;Task </span><span class="si">{}</span><span class="s2">: number of repeats: </span><span class="si">{}</span><span class="s2">, number of folds: </span><span class="si">{}</span><span class="s2">, number of samples </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">task_id</span><span class="p">,</span> <span class="n">n_repeats</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="c1"># Creating utility function</span>
<span class="k">def</span> <span class="nf">print_compare_runtimes</span><span class="p">(</span><span class="n">measures</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">val1</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">[</span><span class="s2">&quot;usercpu_time_millis_training&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">fold</span><span class="p">,</span> <span class="n">val2</span> <span class="ow">in</span> <span class="n">val1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Repeat #</span><span class="si">{}</span><span class="s2">-Fold #</span><span class="si">{}</span><span class="s2">: CPU-</span><span class="si">{:.3f}</span><span class="s2"> vs Wall-</span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">repeat</span><span class="p">,</span> <span class="n">fold</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="n">measures</span><span class="p">[</span><span class="s2">&quot;wall_clock_time_millis_training&quot;</span><span class="p">][</span><span class="n">repeat</span><span class="p">][</span><span class="n">fold</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>OpenML Classification Task
==========================
Task Type Description: https://www.openml.org/tt/TaskType.SUPERVISED_CLASSIFICATION
Task ID..............: 167119
Task URL.............: https://www.openml.org/t/167119
Estimation Procedure.: crossvalidation
Target Feature.......: class
# of Classes.........: 3
Cost Matrix..........: Available
Task 167119: number of repeats: 1, number of folds: 10, number of samples 1.
</pre></div>
</div>
</section>
<section id="case-1-running-a-random-forest-model-on-an-openml-task">
<h2>Case 1: Running a Random Forest model on an OpenML task<a class="headerlink" href="#case-1-running-a-random-forest-model-on-an-openml-task" title="Permalink to this headline">¶</a></h2>
<p>We’ll run a Random Forest model and obtain an OpenML run object. We can
see the evaluations recorded per fold for the dataset and the information
available for this run.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clf</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">run1</span> <span class="o">=</span> <span class="n">openml</span><span class="o">.</span><span class="n">runs</span><span class="o">.</span><span class="n">run_model_on_task</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="n">clf</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">,</span> <span class="n">upload_flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">avoid_duplicate_runs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">measures</span> <span class="o">=</span> <span class="n">run1</span><span class="o">.</span><span class="n">fold_evaluations</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The timing and performance metrics available: &quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">measures</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span>
    <span class="s2">&quot;The performance metric is recorded under `predictive_accuracy` per &quot;</span>
    <span class="s2">&quot;fold and can be retrieved as: &quot;</span>
<span class="p">)</span>
<span class="k">for</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">val1</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">[</span><span class="s2">&quot;predictive_accuracy&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">fold</span><span class="p">,</span> <span class="n">val2</span> <span class="ow">in</span> <span class="n">val1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Repeat #</span><span class="si">{}</span><span class="s2">-Fold #</span><span class="si">{}</span><span class="s2">: </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">repeat</span><span class="p">,</span> <span class="n">fold</span><span class="p">,</span> <span class="n">val2</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>The timing and performance metrics available:
usercpu_time_millis_training
wall_clock_time_millis_training
usercpu_time_millis_testing
usercpu_time_millis
wall_clock_time_millis_testing
wall_clock_time_millis
predictive_accuracy

The performance metric is recorded under `predictive_accuracy` per fold and can be retrieved as:
Repeat #0-Fold #0: 0.7800
Repeat #0-Fold #1: 0.7760
Repeat #0-Fold #2: 0.7820
Repeat #0-Fold #3: 0.7905
Repeat #0-Fold #4: 0.7856
Repeat #0-Fold #5: 0.7887
Repeat #0-Fold #6: 0.7778
Repeat #0-Fold #7: 0.7818
Repeat #0-Fold #8: 0.7880
Repeat #0-Fold #9: 0.7824
</pre></div>
</div>
<p>The remaining entries recorded in <cite>measures</cite> are the runtime records
related as:</p>
<p>usercpu_time_millis = usercpu_time_millis_training + usercpu_time_millis_testing</p>
<p>wall_clock_time_millis = wall_clock_time_millis_training + wall_clock_time_millis_testing</p>
<p>The timing measures recorded as <cite>*_millis_training</cite> contain the per
repeat-per fold timing incurred for the execution of the <cite>.fit()</cite> procedure
of the model. For <cite>usercpu_time_*</cite> the time recorded using <cite>time.process_time()</cite>
is converted to <cite>milliseconds</cite> and stored. Similarly, <cite>time.time()</cite> is used
to record the time entry for <cite>wall_clock_time_*</cite>. The <cite>*_millis_testing</cite> entry
follows the same procedure but for time taken for the <cite>.predict()</cite> procedure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Comparing the CPU and wall-clock training times of the Random Forest model</span>
<span class="n">print_compare_runtimes</span><span class="p">(</span><span class="n">measures</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Repeat #0-Fold #0: CPU-304.059 vs Wall-304.183
Repeat #0-Fold #1: CPU-300.720 vs Wall-300.749
Repeat #0-Fold #2: CPU-308.499 vs Wall-308.545
Repeat #0-Fold #3: CPU-296.903 vs Wall-296.913
Repeat #0-Fold #4: CPU-298.455 vs Wall-298.468
Repeat #0-Fold #5: CPU-295.568 vs Wall-295.588
Repeat #0-Fold #6: CPU-302.521 vs Wall-302.532
Repeat #0-Fold #7: CPU-301.259 vs Wall-301.295
Repeat #0-Fold #8: CPU-306.846 vs Wall-306.893
Repeat #0-Fold #9: CPU-310.954 vs Wall-310.954
</pre></div>
</div>
</section>
<section id="case-2-running-scikit-learn-model-on-an-openml-task-in-parallel">
<h2>Case 2: Running Scikit-learn model on an OpenML task in parallel<a class="headerlink" href="#case-2-running-scikit-learn-model-on-an-openml-task-in-parallel" title="Permalink to this headline">¶</a></h2>
<p>Redefining the model to allow parallelism with <cite>n_jobs=2</cite> (2 cores)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clf</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">run2</span> <span class="o">=</span> <span class="n">openml</span><span class="o">.</span><span class="n">runs</span><span class="o">.</span><span class="n">run_model_on_task</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="n">clf</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">,</span> <span class="n">upload_flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">avoid_duplicate_runs</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
<span class="n">measures</span> <span class="o">=</span> <span class="n">run2</span><span class="o">.</span><span class="n">fold_evaluations</span>
<span class="c1"># The wall-clock time recorded per fold should be lesser than Case 1 above</span>
<span class="n">print_compare_runtimes</span><span class="p">(</span><span class="n">measures</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Repeat #0-Fold #0: CPU-151.374 vs Wall-1068.223
Repeat #0-Fold #1: CPU-87.618 vs Wall-232.960
Repeat #0-Fold #2: CPU-88.931 vs Wall-217.667
Repeat #0-Fold #3: CPU-92.268 vs Wall-225.845
Repeat #0-Fold #4: CPU-86.536 vs Wall-241.683
Repeat #0-Fold #5: CPU-91.921 vs Wall-259.840
Repeat #0-Fold #6: CPU-84.623 vs Wall-218.946
Repeat #0-Fold #7: CPU-91.210 vs Wall-250.160
Repeat #0-Fold #8: CPU-87.944 vs Wall-242.891
Repeat #0-Fold #9: CPU-90.079 vs Wall-235.152
</pre></div>
</div>
<p>Running a Random Forest model on an OpenML task in parallel (all cores available):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Redefining the model to use all available cores with `n_jobs=-1`</span>
<span class="n">clf</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">run3</span> <span class="o">=</span> <span class="n">openml</span><span class="o">.</span><span class="n">runs</span><span class="o">.</span><span class="n">run_model_on_task</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="n">clf</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">,</span> <span class="n">upload_flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">avoid_duplicate_runs</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
<span class="n">measures</span> <span class="o">=</span> <span class="n">run3</span><span class="o">.</span><span class="n">fold_evaluations</span>
<span class="c1"># The wall-clock time recorded per fold should be lesser than the case above,</span>
<span class="c1"># if more than 2 CPU cores are available. The speed-up is more pronounced for</span>
<span class="c1"># larger datasets.</span>
<span class="n">print_compare_runtimes</span><span class="p">(</span><span class="n">measures</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Repeat #0-Fold #0: CPU-86.707 vs Wall-242.629
Repeat #0-Fold #1: CPU-83.292 vs Wall-231.898
Repeat #0-Fold #2: CPU-85.172 vs Wall-226.190
Repeat #0-Fold #3: CPU-84.874 vs Wall-236.192
Repeat #0-Fold #4: CPU-85.710 vs Wall-244.883
Repeat #0-Fold #5: CPU-84.610 vs Wall-218.274
Repeat #0-Fold #6: CPU-85.967 vs Wall-218.020
Repeat #0-Fold #7: CPU-81.328 vs Wall-217.619
Repeat #0-Fold #8: CPU-85.941 vs Wall-241.637
Repeat #0-Fold #9: CPU-81.482 vs Wall-216.973
</pre></div>
</div>
<p>We can now observe that the ratio of CPU time to wallclock time is lower
than in case 1. This happens because joblib by default spawns subprocesses
for the workloads for which CPU time cannot be tracked. Therefore, interpreting
the reported CPU and wallclock time requires knowledge of the parallelization
applied at runtime.</p>
<p>Running the same task with a different parallel backend. Joblib provides multiple
backends: {<cite>loky</cite> (default), <cite>multiprocessing</cite>, <cite>dask</cite>, <cite>threading</cite>, <cite>sequential</cite>}.
The backend can be explicitly set using a joblib context manager. The behaviour of
the job distribution can change and therefore the scale of runtimes recorded too.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">parallel_backend</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;multiprocessing&quot;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">run3_</span> <span class="o">=</span> <span class="n">openml</span><span class="o">.</span><span class="n">runs</span><span class="o">.</span><span class="n">run_model_on_task</span><span class="p">(</span>
        <span class="n">model</span><span class="o">=</span><span class="n">clf</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">,</span> <span class="n">upload_flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">avoid_duplicate_runs</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
<span class="n">measures</span> <span class="o">=</span> <span class="n">run3_</span><span class="o">.</span><span class="n">fold_evaluations</span>
<span class="n">print_compare_runtimes</span><span class="p">(</span><span class="n">measures</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Repeat #0-Fold #0: CPU-339.311 vs Wall-316.144
Repeat #0-Fold #1: CPU-339.748 vs Wall-357.156
Repeat #0-Fold #2: CPU-333.409 vs Wall-348.369
Repeat #0-Fold #3: CPU-326.054 vs Wall-326.666
Repeat #0-Fold #4: CPU-313.459 vs Wall-315.384
Repeat #0-Fold #5: CPU-313.303 vs Wall-314.003
Repeat #0-Fold #6: CPU-322.467 vs Wall-323.424
Repeat #0-Fold #7: CPU-322.686 vs Wall-328.017
Repeat #0-Fold #8: CPU-313.873 vs Wall-346.544
Repeat #0-Fold #9: CPU-306.795 vs Wall-281.277
</pre></div>
</div>
<p>The CPU time interpretation becomes ambiguous when jobs are distributed over an
unknown number of cores or when subprocesses are spawned for which the CPU time
cannot be tracked, as in the examples above. It is impossible for OpenML-Python
to capture the availability of the number of cores/threads, their eventual
utilisation and whether workloads are executed in subprocesses, for various
cases that can arise as demonstrated in the rest of the example. Therefore,
the final interpretation of the runtimes is left to the <cite>user</cite>.</p>
</section>
<section id="case-3-running-and-benchmarking-hpo-algorithms-with-their-runtimes">
<h2>Case 3: Running and benchmarking HPO algorithms with their runtimes<a class="headerlink" href="#case-3-running-and-benchmarking-hpo-algorithms-with-their-runtimes" title="Permalink to this headline">¶</a></h2>
<p>We shall now optimize a similar RandomForest model for the same task using
scikit-learn’s HPO support by using GridSearchCV to optimize our earlier
RandomForest model’s hyperparameter <cite>n_estimators</cite>. Scikit-learn also provides a
<cite>refit_time_</cite> for such HPO models, i.e., the time incurred by training
and evaluating the model on the best found parameter setting. This is
included in the <cite>wall_clock_time_millis_training</cite> measure recorded.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>


<span class="n">clf</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># GridSearchCV model</span>
<span class="n">n_iter</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">grid_pipe</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span>
    <span class="n">estimator</span><span class="o">=</span><span class="n">clf</span><span class="p">,</span>
    <span class="n">param_grid</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;n_estimators&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n_iter</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()},</span>
    <span class="n">cv</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">run4</span> <span class="o">=</span> <span class="n">openml</span><span class="o">.</span><span class="n">runs</span><span class="o">.</span><span class="n">run_model_on_task</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="n">grid_pipe</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">,</span> <span class="n">upload_flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">avoid_duplicate_runs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span>
<span class="p">)</span>
<span class="n">measures</span> <span class="o">=</span> <span class="n">run4</span><span class="o">.</span><span class="n">fold_evaluations</span>
<span class="n">print_compare_runtimes</span><span class="p">(</span><span class="n">measures</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Repeat #0-Fold #0: CPU-6466.371 vs Wall-6474.935
Repeat #0-Fold #1: CPU-6491.879 vs Wall-6512.467
Repeat #0-Fold #2: CPU-6374.956 vs Wall-6459.246
Repeat #0-Fold #3: CPU-6379.986 vs Wall-6410.700
Repeat #0-Fold #4: CPU-6430.721 vs Wall-6462.697
Repeat #0-Fold #5: CPU-6413.152 vs Wall-6424.860
Repeat #0-Fold #6: CPU-6602.940 vs Wall-6637.805
Repeat #0-Fold #7: CPU-6569.420 vs Wall-6594.640
Repeat #0-Fold #8: CPU-6526.628 vs Wall-6476.505
Repeat #0-Fold #9: CPU-6146.280 vs Wall-6172.435
</pre></div>
</div>
<p>Like any optimisation problem, scikit-learn’s HPO estimators also generate
a sequence of configurations which are evaluated, using which the best found
configuration is tracked throughout the trace.
The OpenML run object stores these traces as OpenMLRunTrace objects accessible
using keys of the pattern (repeat, fold, iterations). Here <cite>fold</cite> implies the
outer-cross validation fold as obtained from the task data splits in OpenML.
GridSearchCV here performs grid search over the inner-cross validation folds as
parameterized by the <cite>cv</cite> parameter. Since <cite>GridSearchCV</cite> in this example performs a
<cite>2-fold</cite> cross validation, the runtime recorded per repeat-per fold in the run object
is for the entire <cite>fit()</cite> procedure of GridSearchCV thus subsuming the runtimes of
the 2-fold (inner) CV search performed.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># We earlier extracted the number of repeats and folds for this task:</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# repeats: </span><span class="si">{}</span><span class="se">\n</span><span class="s2"># folds: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_repeats</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">))</span>

<span class="c1"># To extract the training runtime of the first repeat, first fold:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">run4</span><span class="o">.</span><span class="n">fold_evaluations</span><span class="p">[</span><span class="s2">&quot;wall_clock_time_millis_training&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span># repeats: 1
# folds: 10
6474.9345779418945
</pre></div>
</div>
<p>To extract the training runtime of the 1-st repeat, 4-th (outer) fold and also
to fetch the parameters and performance of the evaluations made during
the 1-st repeat, 4-th fold evaluation by the Grid Search model.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_repeat</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_fold</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nb">print</span><span class="p">(</span>
    <span class="s2">&quot;Total runtime for repeat </span><span class="si">{}</span><span class="s2">&#39;s fold </span><span class="si">{}</span><span class="s2">: </span><span class="si">{:4f}</span><span class="s2"> ms&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">_repeat</span><span class="p">,</span> <span class="n">_fold</span><span class="p">,</span> <span class="n">run4</span><span class="o">.</span><span class="n">fold_evaluations</span><span class="p">[</span><span class="s2">&quot;wall_clock_time_millis_training&quot;</span><span class="p">][</span><span class="n">_repeat</span><span class="p">][</span><span class="n">_fold</span><span class="p">]</span>
    <span class="p">)</span>
<span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">_repeat</span><span class="p">,</span> <span class="n">_fold</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">run4</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">trace_iterations</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;n_estimators: </span><span class="si">{:&gt;2}</span><span class="s2"> - score: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">r</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;parameter_n_estimators&quot;</span><span class="p">],</span> <span class="n">r</span><span class="o">.</span><span class="n">evaluation</span>
        <span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Total runtime for repeat 0&#39;s fold 3: 6410.700083 ms
n_estimators:  1 - score: 0.765
n_estimators: 13 - score: 0.798
n_estimators: 25 - score: 0.801
n_estimators: 37 - score: 0.803
n_estimators: 50 - score: 0.804
</pre></div>
</div>
<p>Scikit-learn’s HPO estimators also come with an argument <cite>refit=True</cite> as a default.
In our previous model definition it was set to True by default, which meant that the best
found hyperparameter configuration was used to refit or retrain the model without any inner
cross validation. This extra refit time measure is provided by the scikit-learn model as the
attribute <cite>refit_time_</cite>.
This time is included in the <cite>wall_clock_time_millis_training</cite> measure.</p>
<p>For non-HPO estimators, <cite>wall_clock_time_millis = wall_clock_time_millis_training + wall_clock_time_millis_testing</cite>.</p>
<p>For HPO estimators, <cite>wall_clock_time_millis = wall_clock_time_millis_training + wall_clock_time_millis_testing + refit_time</cite>.</p>
<p>This refit time can therefore be explicitly extracted in this manner:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">extract_refit_time</span><span class="p">(</span><span class="n">run</span><span class="p">,</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">fold</span><span class="p">):</span>
    <span class="n">refit_time</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">run</span><span class="o">.</span><span class="n">fold_evaluations</span><span class="p">[</span><span class="s2">&quot;wall_clock_time_millis&quot;</span><span class="p">][</span><span class="n">repeat</span><span class="p">][</span><span class="n">fold</span><span class="p">]</span>
        <span class="o">-</span> <span class="n">run</span><span class="o">.</span><span class="n">fold_evaluations</span><span class="p">[</span><span class="s2">&quot;wall_clock_time_millis_training&quot;</span><span class="p">][</span><span class="n">repeat</span><span class="p">][</span><span class="n">fold</span><span class="p">]</span>
        <span class="o">-</span> <span class="n">run</span><span class="o">.</span><span class="n">fold_evaluations</span><span class="p">[</span><span class="s2">&quot;wall_clock_time_millis_testing&quot;</span><span class="p">][</span><span class="n">repeat</span><span class="p">][</span><span class="n">fold</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">refit_time</span>


<span class="k">for</span> <span class="n">repeat</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_repeats</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">fold</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_folds</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Repeat #</span><span class="si">{}</span><span class="s2">-Fold #</span><span class="si">{}</span><span class="s2">: </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">repeat</span><span class="p">,</span> <span class="n">fold</span><span class="p">,</span> <span class="n">extract_refit_time</span><span class="p">(</span><span class="n">run4</span><span class="p">,</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">fold</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Repeat #0-Fold #0: 1373.4636
Repeat #0-Fold #1: 1374.3668
Repeat #0-Fold #2: 1379.4777
Repeat #0-Fold #3: 1382.1554
Repeat #0-Fold #4: 1387.5759
Repeat #0-Fold #5: 1397.5749
Repeat #0-Fold #6: 1446.4300
Repeat #0-Fold #7: 1449.4166
Repeat #0-Fold #8: 1349.6704
Repeat #0-Fold #9: 1058.3115
</pre></div>
</div>
<p>Along with the GridSearchCV already used above, we demonstrate how such
optimisation traces can be retrieved by showing an application of these
traces - comparing the speed of finding the best configuration using
RandomizedSearchCV and GridSearchCV available with scikit-learn.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># RandomizedSearchCV model</span>
<span class="n">rs_pipe</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span>
    <span class="n">estimator</span><span class="o">=</span><span class="n">clf</span><span class="p">,</span>
    <span class="n">param_distributions</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;n_estimators&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="p">},</span>
    <span class="n">cv</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">n_iter</span><span class="o">=</span><span class="n">n_iter</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">run5</span> <span class="o">=</span> <span class="n">openml</span><span class="o">.</span><span class="n">runs</span><span class="o">.</span><span class="n">run_model_on_task</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="n">rs_pipe</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">,</span> <span class="n">upload_flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">avoid_duplicate_runs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Since for the call to <code class="docutils literal notranslate"><span class="pre">openml.runs.run_model_on_task</span></code> the parameter
<code class="docutils literal notranslate"><span class="pre">n_jobs</span></code> is set to its default <code class="docutils literal notranslate"><span class="pre">None</span></code>, the evaluations across the OpenML folds
are not parallelized. Hence, the time recorded is agnostic to the <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>
being set at both the HPO estimator <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code> as well as the base
estimator <code class="docutils literal notranslate"><span class="pre">RandomForestClassifier</span></code> in this case. The OpenML extension only records the
time taken for the completion of the complete <code class="docutils literal notranslate"><span class="pre">fit()</span></code> call, per-repeat per-fold.</p>
<p>This notion can be used to extract and plot the best found performance per
fold by the HPO model and the corresponding time taken for search across
that fold. Moreover, since <code class="docutils literal notranslate"><span class="pre">n_jobs=None</span></code> for <code class="docutils literal notranslate"><span class="pre">openml.runs.run_model_on_task</span></code>
the runtimes per fold can be cumulatively added to plot the trace against time.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">extract_trace_data</span><span class="p">(</span><span class="n">run</span><span class="p">,</span> <span class="n">n_repeats</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;wall_clock_time_millis_training&quot;</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">key</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;score&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;runtime&quot;</span><span class="p">:</span> <span class="p">[]}</span>
    <span class="k">for</span> <span class="n">i_r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_repeats</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i_f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_folds</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;runtime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">run</span><span class="o">.</span><span class="n">fold_evaluations</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i_r</span><span class="p">][</span><span class="n">i_f</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">run</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">trace_iterations</span><span class="p">[(</span><span class="n">i_r</span><span class="p">,</span> <span class="n">i_f</span><span class="p">,</span> <span class="n">i_i</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">selected</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;score&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">evaluation</span><span class="p">)</span>
                    <span class="k">break</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">get_incumbent_trace</span><span class="p">(</span><span class="n">trace</span><span class="p">):</span>
    <span class="n">best_score</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">inc_trace</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trace</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">best_score</span><span class="p">:</span>
            <span class="n">best_score</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">r</span>
        <span class="n">inc_trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_score</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inc_trace</span>


<span class="n">grid_data</span> <span class="o">=</span> <span class="n">extract_trace_data</span><span class="p">(</span><span class="n">run4</span><span class="p">,</span> <span class="n">n_repeats</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">)</span>
<span class="n">rs_data</span> <span class="o">=</span> <span class="n">extract_trace_data</span><span class="p">(</span><span class="n">run5</span><span class="p">,</span> <span class="n">n_repeats</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">grid_data</span><span class="p">[</span><span class="s2">&quot;runtime&quot;</span><span class="p">]),</span> <span class="n">get_incumbent_trace</span><span class="p">(</span><span class="n">grid_data</span><span class="p">[</span><span class="s2">&quot;score&quot;</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Grid Search&quot;</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">rs_data</span><span class="p">[</span><span class="s2">&quot;runtime&quot;</span><span class="p">]),</span> <span class="n">get_incumbent_trace</span><span class="p">(</span><span class="n">rs_data</span><span class="p">[</span><span class="s2">&quot;score&quot;</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Random Search&quot;</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Wallclock time (in milliseconds)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;1 - Accuracy&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Optimisation Trace Comparison&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../../_images/sphx_glr_fetch_runtimes_tutorial_001.png" srcset="../../_images/sphx_glr_fetch_runtimes_tutorial_001.png" alt="Optimisation Trace Comparison" class = "sphx-glr-single-img"/></section>
<section id="case-4-running-models-that-scikit-learn-doesn-t-parallelize">
<h2>Case 4: Running models that scikit-learn doesn’t parallelize<a class="headerlink" href="#case-4-running-models-that-scikit-learn-doesn-t-parallelize" title="Permalink to this headline">¶</a></h2>
<p>Both scikit-learn and OpenML depend on parallelism implemented through <cite>joblib</cite>.
However, there can be cases where either models cannot be parallelized or don’t
depend on joblib for its parallelism. 2 such cases are illustrated below.</p>
<p>Running a Decision Tree model that doesn’t support parallelism implicitly, but
using OpenML to parallelize evaluations for the outer-cross validation folds.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dt</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">()</span>

<span class="n">run6</span> <span class="o">=</span> <span class="n">openml</span><span class="o">.</span><span class="n">runs</span><span class="o">.</span><span class="n">run_model_on_task</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">,</span> <span class="n">upload_flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">avoid_duplicate_runs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span>
<span class="p">)</span>
<span class="n">measures</span> <span class="o">=</span> <span class="n">run6</span><span class="o">.</span><span class="n">fold_evaluations</span>
<span class="n">print_compare_runtimes</span><span class="p">(</span><span class="n">measures</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Repeat #0-Fold #0: CPU-105.092 vs Wall-105.094
Repeat #0-Fold #1: CPU-106.613 vs Wall-107.037
Repeat #0-Fold #2: CPU-108.366 vs Wall-108.570
Repeat #0-Fold #3: CPU-108.413 vs Wall-113.229
Repeat #0-Fold #4: CPU-104.559 vs Wall-104.780
Repeat #0-Fold #5: CPU-107.640 vs Wall-107.688
Repeat #0-Fold #6: CPU-106.841 vs Wall-106.911
Repeat #0-Fold #7: CPU-110.860 vs Wall-116.400
Repeat #0-Fold #8: CPU-107.170 vs Wall-107.350
Repeat #0-Fold #9: CPU-112.186 vs Wall-114.070
</pre></div>
</div>
<p>Although the decision tree does not run in parallel, it can release the
<a class="reference external" href="https://docs.python.org/dev/glossary.html#term-global-interpreter-lock">Python GIL</a>.
This can result in surprising runtime measures as demonstrated below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">parallel_backend</span><span class="p">(</span><span class="s2">&quot;threading&quot;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">run7</span> <span class="o">=</span> <span class="n">openml</span><span class="o">.</span><span class="n">runs</span><span class="o">.</span><span class="n">run_model_on_task</span><span class="p">(</span>
        <span class="n">model</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">,</span> <span class="n">upload_flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">avoid_duplicate_runs</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
<span class="n">measures</span> <span class="o">=</span> <span class="n">run7</span><span class="o">.</span><span class="n">fold_evaluations</span>
<span class="n">print_compare_runtimes</span><span class="p">(</span><span class="n">measures</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Repeat #0-Fold #0: CPU-220.575 vs Wall-155.846
Repeat #0-Fold #1: CPU-213.239 vs Wall-150.917
Repeat #0-Fold #2: CPU-216.038 vs Wall-153.019
Repeat #0-Fold #3: CPU-217.663 vs Wall-151.687
Repeat #0-Fold #4: CPU-204.160 vs Wall-141.572
Repeat #0-Fold #5: CPU-184.520 vs Wall-110.075
Repeat #0-Fold #6: CPU-225.133 vs Wall-156.301
Repeat #0-Fold #7: CPU-176.515 vs Wall-110.689
Repeat #0-Fold #8: CPU-213.038 vs Wall-149.650
Repeat #0-Fold #9: CPU-168.449 vs Wall-107.217
</pre></div>
</div>
<p>Running a Neural Network from scikit-learn that uses scikit-learn independent
parallelism using libraries such as <a class="reference external" href="https://scikit-learn.org/stable/computing/parallelism.html#parallel-numpy-routines-from-numerical-libraries">MKL, OpenBLAS or BLIS</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mlp</span> <span class="o">=</span> <span class="n">MLPClassifier</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">run8</span> <span class="o">=</span> <span class="n">openml</span><span class="o">.</span><span class="n">runs</span><span class="o">.</span><span class="n">run_model_on_task</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="n">mlp</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">,</span> <span class="n">upload_flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">avoid_duplicate_runs</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
<span class="n">measures</span> <span class="o">=</span> <span class="n">run8</span><span class="o">.</span><span class="n">fold_evaluations</span>
<span class="n">print_compare_runtimes</span><span class="p">(</span><span class="n">measures</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/sklearn/neural_network/_multilayer_perceptron.py:692: ConvergenceWarning: Stochastic Optimizer: Maximum iterations (10) reached and the optimization hasn&#39;t converged yet.
  warnings.warn(
/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/sklearn/neural_network/_multilayer_perceptron.py:692: ConvergenceWarning: Stochastic Optimizer: Maximum iterations (10) reached and the optimization hasn&#39;t converged yet.
  warnings.warn(
/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/sklearn/neural_network/_multilayer_perceptron.py:692: ConvergenceWarning: Stochastic Optimizer: Maximum iterations (10) reached and the optimization hasn&#39;t converged yet.
  warnings.warn(
/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/sklearn/neural_network/_multilayer_perceptron.py:692: ConvergenceWarning: Stochastic Optimizer: Maximum iterations (10) reached and the optimization hasn&#39;t converged yet.
  warnings.warn(
/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/sklearn/neural_network/_multilayer_perceptron.py:692: ConvergenceWarning: Stochastic Optimizer: Maximum iterations (10) reached and the optimization hasn&#39;t converged yet.
  warnings.warn(
/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/sklearn/neural_network/_multilayer_perceptron.py:692: ConvergenceWarning: Stochastic Optimizer: Maximum iterations (10) reached and the optimization hasn&#39;t converged yet.
  warnings.warn(
/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/sklearn/neural_network/_multilayer_perceptron.py:692: ConvergenceWarning: Stochastic Optimizer: Maximum iterations (10) reached and the optimization hasn&#39;t converged yet.
  warnings.warn(
/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/sklearn/neural_network/_multilayer_perceptron.py:692: ConvergenceWarning: Stochastic Optimizer: Maximum iterations (10) reached and the optimization hasn&#39;t converged yet.
  warnings.warn(
/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/sklearn/neural_network/_multilayer_perceptron.py:692: ConvergenceWarning: Stochastic Optimizer: Maximum iterations (10) reached and the optimization hasn&#39;t converged yet.
  warnings.warn(
/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/sklearn/neural_network/_multilayer_perceptron.py:692: ConvergenceWarning: Stochastic Optimizer: Maximum iterations (10) reached and the optimization hasn&#39;t converged yet.
  warnings.warn(
Repeat #0-Fold #0: CPU-2276.057 vs Wall-2276.300
Repeat #0-Fold #1: CPU-2369.088 vs Wall-2261.856
Repeat #0-Fold #2: CPU-2359.077 vs Wall-2252.812
Repeat #0-Fold #3: CPU-2373.615 vs Wall-2266.922
Repeat #0-Fold #4: CPU-2375.510 vs Wall-2273.590
Repeat #0-Fold #5: CPU-2375.827 vs Wall-2268.429
Repeat #0-Fold #6: CPU-2342.694 vs Wall-2235.868
Repeat #0-Fold #7: CPU-2357.552 vs Wall-2254.498
Repeat #0-Fold #8: CPU-2337.929 vs Wall-2230.779
Repeat #0-Fold #9: CPU-2336.467 vs Wall-2228.997
</pre></div>
</div>
</section>
<section id="case-5-running-scikit-learn-models-that-don-t-release-gil">
<h2>Case 5: Running Scikit-learn models that don’t release GIL<a class="headerlink" href="#case-5-running-scikit-learn-models-that-don-t-release-gil" title="Permalink to this headline">¶</a></h2>
<p>Certain Scikit-learn models do not release the <a class="reference external" href="https://docs.python.org/dev/glossary.html#term-global-interpreter-lock">Python GIL</a> and
are also not executed in parallel via a BLAS library. In such cases, the
CPU times and wallclock times are most likely trustworthy. Note however
that only very few models such as naive Bayes models are of this kind.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clf</span> <span class="o">=</span> <span class="n">GaussianNB</span><span class="p">()</span>

<span class="k">with</span> <span class="n">parallel_backend</span><span class="p">(</span><span class="s2">&quot;multiprocessing&quot;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">run9</span> <span class="o">=</span> <span class="n">openml</span><span class="o">.</span><span class="n">runs</span><span class="o">.</span><span class="n">run_model_on_task</span><span class="p">(</span>
        <span class="n">model</span><span class="o">=</span><span class="n">clf</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">,</span> <span class="n">upload_flow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">avoid_duplicate_runs</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
<span class="n">measures</span> <span class="o">=</span> <span class="n">run9</span><span class="o">.</span><span class="n">fold_evaluations</span>
<span class="n">print_compare_runtimes</span><span class="p">(</span><span class="n">measures</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Repeat #0-Fold #0: CPU-61.592 vs Wall-61.689
Repeat #0-Fold #1: CPU-62.036 vs Wall-63.024
Repeat #0-Fold #2: CPU-56.237 vs Wall-59.132
Repeat #0-Fold #3: CPU-56.352 vs Wall-57.309
Repeat #0-Fold #4: CPU-56.557 vs Wall-77.099
Repeat #0-Fold #5: CPU-56.926 vs Wall-56.970
Repeat #0-Fold #6: CPU-56.446 vs Wall-64.460
Repeat #0-Fold #7: CPU-62.083 vs Wall-62.113
Repeat #0-Fold #8: CPU-56.129 vs Wall-56.165
Repeat #0-Fold #9: CPU-55.646 vs Wall-55.674
</pre></div>
</div>
</section>
<section id="summmary">
<h2>Summmary<a class="headerlink" href="#summmary" title="Permalink to this headline">¶</a></h2>
<p>The scikit-learn extension for OpenML-Python records model runtimes for the
CPU-clock and the wall-clock times. The above examples illustrated how these
recorded runtimes can be extracted when using a scikit-learn model and under
parallel setups too. To summarize, the scikit-learn extension measures the:</p>
<ul class="simple">
<li><p><cite>CPU-time</cite> &amp; <cite>wallclock-time</cite> for the whole run</p>
<ul>
<li><p>A run here corresponds to a call to <cite>run_model_on_task</cite> or <cite>run_flow_on_task</cite></p></li>
<li><p>The recorded time is for the model fit for each of the outer-cross validations folds,
i.e., the OpenML data splits</p></li>
</ul>
</li>
<li><p>Python’s <cite>time</cite> module is used to compute the runtimes</p>
<ul>
<li><p><cite>CPU-time</cite> is recorded using the responses of <cite>time.process_time()</cite></p></li>
<li><p><cite>wallclock-time</cite> is recorded using the responses of <cite>time.time()</cite></p></li>
</ul>
</li>
<li><p>The timings recorded by OpenML per outer-cross validation fold is agnostic to
model parallelisation</p>
<ul>
<li><p>The wallclock times reported in Case 2 above highlights the speed-up on using <cite>n_jobs=-1</cite>
in comparison to <cite>n_jobs=2</cite>, since the timing recorded by OpenML is for the entire
<cite>fit()</cite> procedure, whereas the parallelisation is performed inside <cite>fit()</cite> by scikit-learn</p></li>
<li><p>The CPU-time for models that are run in parallel can be difficult to interpret</p></li>
</ul>
</li>
<li><p><cite>CPU-time</cite> &amp; <cite>wallclock-time</cite> for each search per outer fold in an HPO run</p>
<ul>
<li><p>Reports the total time for performing search on each of the OpenML data split, subsuming
any sort of parallelism that happened as part of the HPO estimator or the underlying
base estimator</p></li>
<li><p>Also allows extraction of the <cite>refit_time</cite> that scikit-learn measures using <cite>time.time()</cite>
for retraining the model per outer fold, for the best found configuration</p></li>
</ul>
</li>
<li><p><cite>CPU-time</cite> &amp; <cite>wallclock-time</cite> for models that scikit-learn doesn’t parallelize</p>
<ul>
<li><p>Models like Decision Trees or naive Bayes don’t parallelize and thus both the wallclock and
CPU times are similar in runtime for the OpenML call</p></li>
<li><p>However, models implemented in Cython, such as the Decision Trees can release the GIL and
still run in parallel if a <cite>threading</cite> backend is used by joblib.</p></li>
<li><p>Scikit-learn Neural Networks can undergo parallelization implicitly owing to thread-level
parallelism involved in the linear algebraic operations and thus the wallclock-time and
CPU-time can differ.</p></li>
</ul>
</li>
</ul>
<p>Because of all the cases mentioned above it is crucial to understand which case is triggered
when reporting runtimes for scikit-learn models measured with OpenML-Python!</p>
<p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 2 minutes  47.601 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-examples-30-extended-fetch-runtimes-tutorial-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../../_downloads/8c382c76eb99f4156c49950f4c9349a0/fetch_runtimes_tutorial.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">fetch_runtimes_tutorial.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../../_downloads/b38628dd5a6df6d64efcbd57ac258e5f/fetch_runtimes_tutorial.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">fetch_runtimes_tutorial.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2014-2021, the OpenML-Python team.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.2.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>